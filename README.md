# VoronoiGame
Copyright © 2018年 K.Hirano All rights reserved. 

作成日2018/11/08 

最終更新日2018/11/20



## 0. ゲームの説明

ゲームのおおまかな説明は省略しますが，今後の説明のために，用語を定義します．

### 用語

| 用語            | 内容                                                         |
| --------------- | ------------------------------------------------------------ |
| 盤/盤面         | 扱うグラフのこと．<br />今回は10*10のグリッドグラフに決まった数の重み（得点）を配置するが，<br />重みはランダムに与える．重みの設定が違う盤は違う盤とみなす． |
| 手番順序        | 公平さを保つために，一つの盤に対して全ての手番順で対戦をする．<br />したがって，3人プレイ時には，1つの盤に対して3!回対戦する． |
| ゲーム番号i   | i回目のゲーム．ゲームごとに盤面は変わる．                  |
| 手番順序番号s | 手番順序に対して与えられた番号．<br />ゲーム番号が同じであれば，手番順序番号が異なっても盤面は同じ． |
| ゲーム(i,s)   | ゲーム番号i，手番順序sの対戦．                           |
| ターンj       | ノードを3個選択するとき，1個目の選択をターン0，2個目の選択をターン1,...とする． |



## 1. 環境の準備

ここでは，環境の準備をしながら対戦の実行方法の一例を紹介します．

### 1.1 実行環境構築

- Java1.8以降のインストール
- Python3系のインストール（Anacondaを推奨）
- busyboxのダウンロード（Windowsの場合）

#### 補足とbusyboxのダウンロード

busyboxをダウンロードするのは，Linuxライクに使えるターミナルを利用したいからです．

MacやLinuxを使用する場合には不要です．

他にCygwinや統合ターミナルを持つVSCodeなどもありますが，busyboxを推奨します．

以下の記事を参考にしながら，busybox64.exeをダウンロードしてください．

https://qiita.com/tetsuy/items/22cba0bc2048967b270a



### 1.2 clone

ターミナルで以下を実行

`git clone https://github.com/a14ehsr/VoronoiGame.git`

もしくはdownload zipからダウンロードして適当なディレクトリに解凍してください．  

### 1.3 カレントディレクトリを移動

windowsの場合，コマンドプロンプトを起動し，busybox.exeを以下のようにして起動してください．

`busybox64.exe sh -l`

VoronoiGameのディレクトリまで移動してください．

ホームディレクトリ直下に配置した場合にはターミナルで以下を実行すれば良いです．

`cd VoronoiGame`



### 1.4 サンプルを動かしてみる

#### サンプルAIのコピー

`sample_programs`に各言語のサンプルが用意されているので，

プログラムをプールするディレクトリの`ai_programs` にコピーする．

以下を実行すれば良い．

```
cp sample_programs/cpp/P_sample.cpp ai_programs/
cp sample_programs/java/P_Sample.java ai_programs/
cp sample_programs/python/P_sample.py ai_programs/
```



#### プラットフォームのコンパイル

以下を実行する．

```
sh shell/compile.sh
```
環境によってはshが使えない場合があるようです．その場合には`./shell/compile.sh`としてください．


#### AIのプログラムをコンパイルする

以下を実行することで，`ai_programs`内の`P_`から始まるプログラムを自動でコンパイルし，

実行コマンドリストのテキストファイルを生成します．

```a
sh shell/auto_compile.sh
```

##### python3コマンドが無いというエラーが出た場合

Windows環境でAnacondaをインストールした場合に，`python3`コマンドが生成されていない場合が確認されています．その場合には，`resoruce/setting/python/run_command.txt`の`python3`を`python`に書き換えてください．（ただし，`python`コマンドが使えることは先に確認してください．）



#### テスト実行する

以下を実行することで，プラットフォームが用意している単純なAIとテスト対戦を行う．

これによって，実行時エラーが発生するプログラムを除いた，

対戦プログラムの実行コマンドリストのテキストファイルを生成する．

 ```
sh shell/test.sh
 ```



#### 対戦を実行する

##### 2人対戦

以下を実行することで，先に用意した対戦プログラムとプラットフォームが用意している単純なAIを合わせた

全ての組み合わせの対戦を実行します．

```
sh shell/auto_run.sh 2
```

以下の様な出力が出れば，問題ないです．

```
設定終了
players  : P_SampleCpp P_SampleJava
勝ち点合計:38 21
players  : P_SampleCpp P_SamplePython
勝ち点合計:34 26
players  : P_SampleCpp P_Random
勝ち点合計:33 26
players  : P_SampleJava P_SamplePython
勝ち点合計:36 23
players  : P_SampleJava P_Random
勝ち点合計:24 36
players  : P_SamplePython P_Random
勝ち点合計:28 32
RESULT
                          0    1    2    3  | r1 r2 (times)
  0,       P_SampleCpp    0   38   34   33  |  0  3
  1,      P_SampleJava   21    0   36   24  |  2  1
  2,    P_SamplePython   26   23    0   28  |  3  0
  3,          P_Random   26   36   32    0  |  1  2
```

###### RESULTの見方

プレイヤー0がプレイヤー1と戦った時に，勝ち点38を記録し……と読み，

 r1(1位)を0回，r2(2位)を3回取ったと読みます．



##### 3人対戦

上の例では，2人対戦を行ないましたが，以下の実行で3人対戦もできます．

実行できるか試してみてください．

```
sh shell/auto_run.sh 3
```



## 2. AIプログラムの準備

1.3でコピーしたプログラムを改変して，それぞれのAIを作ります．

ファイル名を`P_` から始まる適当な名前に変更することを推奨します．

### 2.1 AIの作り方．
前準備として，playerNameを書き換えてください．(例: playerNmae = "Yamada Taro") 
サンプルの関数`select`を修正して，設計したAIを実装します．

#### __コーディングにあたっての注意事項__
デバッグなどの出力を行いたい場合には，**必ず** 標準エラー出力を使用してください．

標準エラー関数は以下のようなものがそれぞれの言語にあります（他にもある場合があります）．

| 言語   | 関数                  |
| ------ | --------------------- |
| C++    | std::cerr >> str      |
| Java   | System.err.print(str) |
| Python | sys.stderr.write(str) |

### 2.2 サンプルプログラムの詳細

#### グラフについて

グラフは一般のグラフにも対応できるようにデータを受け取ります．

サンプルプログラム内の関数`loadGraph`で読み込みを行なっています．

具体的に受け取る情報は以下の通りです．

| 変数名          | 内容                 |
| --------------- | -------------------- |
| numberOfNodes | ノード数             |
| numberOfEdges | 辺数                 |
| weight        | 各ノードの重み       |
| edges         | 各辺の両端ノード番号 |

今回使用しているグラフはグリッドグラフなので，各自都合の良いように書き換えても構いません．

グリッドの左上から右方向に0,1,...numberOfNodes という並びです．

ただし，選択するノード番号は，入力されたグラフのノード番号なので，

データ構造を変更する場合には気をつけてください．



#### パラメタについて

| 変数名              | 説明                                                         |
| ------------------- | ------------------------------------------------------------ |
| numberOfPlayers     | 対戦プレイヤー数（何人対戦なのか）                           |
| numberOfGames       | 対戦ゲーム数                                                 |
| numberOfSelectNodes | 1ゲームあたりに選択するノードの数                            |
| patternSize         | 対戦手番順序の種類数（2人対戦なら2!=2, 3人対戦なら3!=6） |
| playerCode          | プレイヤーの識別番号（0からnumberOfPlayers-1までのいずれか） |
| numberOfNodes       | グラフのノード数                                             |
| numberOfEdges       | グラフの辺数                                                 |
| edges               | グラフの辺情報の2次元配列（ノードedges[i][0]とノードedges[i][1]の間に辺がある） |
| weight              | グラフのノードの重み情報の1次元配列（ノードiの重みはweight[i]） |



#### 関数`select`について

関数にはそれまでのゲームの記録を渡している．

引数の説明は以下の通りです．

| 変数名         | 説明                                                         |
| -------------- | ------------------------------------------------------------ |
| gameRecord     | ゲームごとにノードの獲得状況を記録した4次元配列              |
| game           | 現在のゲーム番号（0からnumberOfPlayers-1までのいずれか）     |
| sequenceNumber | 現在の手番順番番号（0からpatternSize-1までのいずれか）       |
| sequence       | 手番順序の配列（またはリスト）．中身はプレイヤーの識別番号． |

##### gameRecordについて

- gameRecord[i][s][j][0]はゲーム(i, s)のノードjの獲得プレイヤー番号
- gameRecord[i][s][j][1]はゲーム(i, s)のノードjの獲得ターン



##  3. サンプルと対戦

完成したプログラムで対戦させてみましょう．

###  3.1 コンパイル

作ったプログラムをコンパイルします．

普通にコンパイルしても良いですし，

プログラムが`ai_programs`にあるのであれば，

1.3で使った自動コンパイルプログラムを使用してください．

###### 再掲

```
sh shell/auto_compile.sh
```



### 3.2 サンプルと戦わせる

サンプルプログラムと対戦させます．以下のコマンドを実行してください. 

```
sh shell/run_sample.sh 実行コマンド
```

実行コマンドには`"./a.out"`や`"java P_Name"` などを入力してください．

コマンドを一つの文字列とみなす必要があるので，

実行コマンドに空白文字が含まれる場合には`"`で囲ってください．

サンプルは以下の内容です．

| 名前     | 戦略                                                         |
| -------- | ------------------------------------------------------------ |
| P_Random | 取得可能なノードをランダムに選択する                         |
| P_Max    | 取得可能なノードの中で重みが最大のノードを選択する<br />（複数ある場合はランダム） |

また，以下のコマンドでサンプルとの対戦をしつつ，描画もできます．

```
sh shell/run_sample_visible.sh 実行コマンド
```



### 3.3 細かにオプションを指定する

以下の実行コマンドに対し，複数のオプションを入力することで，対戦の設定や出力を変更できる．

```
sh shell/run_normal.sh
```

| オプション  | 説明                                                         | default |
| ----------- | ------------------------------------------------------------ | ------: |
| -p str      | 実行コマンドリストにstrを追加する                            |       - |
| -nop num    | 対戦人数をnumに設定する                                      |       2 |
| -nosn num   | 1ゲームの選択ノード数をnumに設定する                         |       7 |
| -game num   | ゲーム数を設定する                                           |      30 |
| -v bool     | 描画を行う<br />（ゲーム数やAIの数が多い時は終わらなくなるかもしれないので注意） |   false |
| -olevel num | 出力レベルをnumに設定する                                    |       1 |
| -auto bool  | resource/command_list/command_list_green.txtの<br />実行コマンドを実行コマンドリストに追加する．<br />trueの場合，サンプルプログラムを一緒に追加する． |       - |
| -test num   | resource/command_list/command_list.txtの実行コマンドを<br />の実行コマンドとサンプルプログラムでnum回ゲームを行う． |       - |

また，出力レベルは以下の通りである．

| レベル | 出力内容                                              |
| ------ | ----------------------------------------------------- |
| 1      | 対戦の結果（勝ち点）のみ                              |
| 2      | レベル1の内容に加えて各ゲームの利得を出力             |
| 3      | レベル2の内容に加えて各ゲームのノードの獲得状況を出力 |

また，以上のオプションを組み合わせたいくつかのshellscriptを用意している．

| 実行方法                                                     | 内容                                                |
| ------------------------------------------------------------ | --------------------------------------------------- |
| `sh shell/run.sh num "実行コマンド" "実行コマンド" ("実行コマンド")  ` | 対戦人数numで，実行コマンドを対戦させる．           |
| `sh shell/run_visible.sh num "実行コマンド" "実行コマンド" `("実行コマンド") | 対戦人数numで，実行コマンドを対戦させ，描画も行う． |



## 4. 動作確認済み環境
### Java1.8
~~~
java version "1.8.0_162"
Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)
~~~
### Python

~~~
Python 3.6.3 |Anaconda, Inc.| (default, Oct  6 2017, 12:04:38) 
[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin
~~~
### PC
~~~
macOS 10.13.4
~~~

### 補足
Windows環境での実行も確認済みですが，一部挙動に不安定な箇所があります．

busybox利用時の不具合として，対戦用プログラムがうまく動かないことがあるなどがあります．再現性はないですが，出力レベルを2に上げることによって解消されました．

busybox以外利用時の挙動に関して保証はしません．



## 5. 多対多実行について
先に説明した通り，複数のプログラムで自動対戦を行う機能があります．

コンパイル処理はPythonで実装しています．

`ai_programs/`に使用するプログラムを配置してください．

なお，`P_`から始まるプログラムのみを対象にしています．

ディレクトリ内部を再帰的に探索して実行ファイルを取得するので，ディレクトリなどは適当な構成で問題ありません．



## 6. その他細かい設定等について

各言語のコンパイル，実行コマンドの変更やオプション指定ができます．

`resource/setting/{各言語}/`の任意のファイルの中身を書き換えてください．



また，ゲーム数などのdefaultの数値は`resource/setting/setting.txt`に記述されています．

ここを変更することによって変更が可能です．

ただし実行時オプションでの指定も可能なので，そちらを推奨します．



対戦終了時の結果は`resource/result/result.csv`にも記録されます．

必要に応じて参照やコピーを取るなどしてください．